/*Generated by MPS */

import javax.swing.JPanel;
import java.awt.GridLayout;
import javax.swing.JFrame;
import javax.swing.Icon;
import javax.swing.UIManager;
import javax.swing.plaf.metal.MetalLookAndFeel;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.ImageIcon;
import java.awt.Dimension;
import java.awt.BorderLayout;
import javax.swing.JOptionPane;
import java.awt.Color;
import javax.swing.SwingUtilities;
import java.awt.Font;

public abstract class RobotFrame {
  public static final int HEIGHT = 12;
  public static final int WIDTH = 16;
  private static final int CELL_SIZE = 70;
  protected final int width = CELL_SIZE * WIDTH;
  protected final int height = CELL_SIZE * HEIGHT;
  protected final JPanel canvas = new JPanel(new GridLayout(HEIGHT, WIDTH), true);
  private int row = 1;
  private int col = 1;
  private Direction direction = Direction.east;
  private final Cell[][] world = new Cell[HEIGHT][WIDTH];
  private final VisualCell[][] visuals = new VisualCell[HEIGHT][WIDTH];
  private final JFrame frame = new JFrame("Robot Robot");
  private Icon karelIconNorth;
  private Icon karelIconEast;
  private Icon karelIconSouth;
  private Icon karelIconWest;
  private boolean stopped = false;
  public RobotFrame() {
  }
  public final void initializeComponents() {
    try {
      UIManager.setLookAndFeel(new MetalLookAndFeel());
    } catch (UnsupportedLookAndFeelException e) {
      throw new RuntimeException(e);
    }
    ClassLoader classLoader = getClass().getClassLoader();
    karelIconNorth = new ImageIcon(classLoader.getResource("kaja/kajaNorth.png"));
    karelIconEast = new ImageIcon(classLoader.getResource("kaja/kajaEast.png"));
    karelIconSouth = new ImageIcon(classLoader.getResource("kaja/kajaSouth.png"));
    karelIconWest = new ImageIcon(classLoader.getResource("kaja/kajaWest.png"));

    for (int i = 0; i < HEIGHT; i++) {
      for (int j = 0; j < WIDTH; j++) {
        boolean shouldBeWall = i == 0 || i == HEIGHT - 1 || j == 0 || j == WIDTH - 1;
        world[i][j] = new Cell(shouldBeWall);
        VisualCell button = new VisualCell();
        button.setEnabled(false);
        visuals[i][j] = button;
        canvas.add(button);
      }

    }
    world[1][1].setRobot();
    frame.setPreferredSize(new Dimension(width, height));
    frame.setResizable(true);
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.add(BorderLayout.CENTER, canvas);
    frame.setVisible(true);
    frame.pack();
    updateUI();
  }
  public final void run() {
    perform();
  }
  protected abstract void perform();
  public void reportError(String msg) {
    JOptionPane.showMessageDialog(canvas, msg, "Error", JOptionPane.ERROR_MESSAGE);
    stop();
  }
  public void trace(String msg) {
    JOptionPane.showMessageDialog(canvas, msg, "Trace", JOptionPane.INFORMATION_MESSAGE);
  }
  protected Cell getCurrentCell() {
    return world[row][col];
  }
  protected Cell getNextCell() {
    switch (direction) {
      case north:
        return world[row - 1][col];
      case east:
        return world[row][col + 1];
      case south:
        return world[row + 1][col];
      case west:
        return world[row][col - 1];
      default:
        return null;
    }
  }
  protected void moveRobot() {
    if (stopped) {
      return;
    }
    getCurrentCell().unsetRobot();
    switch (direction) {
      case north:
        row -= 1;
        break;
      case east:
        col += 1;
        break;
      case south:
        row += 1;
        break;
      case west:
        col -= 1;
      default:
    }
    getCurrentCell().setRobot();
    updateUI();
  }
  protected void turnLeft() {
    if (stopped) {
      return;
    }
    switch (direction) {
      case north:
        direction = Direction.west;
        break;
      case east:
        direction = Direction.north;
        break;
      case south:
        direction = Direction.east;
        break;
      case west:
        direction = Direction.south;
      default:
    }
    updateUI();
  }
  protected boolean canMove() {
    return !(getNextCell().isWall());
  }
  protected void addMark() {
    if (stopped) {
      return;
    }
    getCurrentCell().addMark();
    updateUI();
  }
  protected void removeMark() {
    if (stopped) {
      return;
    }
    getCurrentCell().removeMark();
    updateUI();
  }
  protected boolean isWall() {
    return getNextCell().isWall();
  }
  protected boolean isMark() {
    return getCurrentCell().getMarks() > 0;
  }
  protected boolean isMark(int row, int col) {
    return world[row][col].getMarks() > 0;
  }
  protected boolean heading(Direction direction) {
    return this.direction == direction;
  }
  protected boolean isFull() {
    return getCurrentCell().getMarks() == 8;
  }
  protected boolean isFull(int row, int col) {
    return world[row][col].getMarks() == 8;
  }
  protected void pause() {
    try {
      Thread.sleep(500);
    } catch (InterruptedException e) {
    }
  }
  protected void minipause() {
    try {
      Thread.sleep(50);
    } catch (InterruptedException e) {
    }
  }
  protected void stop() {
    stopped = true;
    updateUI();
  }
  protected void addMark(int row, int col) {
    if (stopped) {
      return;
    }
    world[row][col].addMark();
    updateUI();
  }
  protected void removeMark(int row, int col) {
    if (stopped) {
      return;
    }
    world[row][col].removeMark();
    updateUI();
  }
  protected void addWall(int row, int col) {
    if (stopped) {
      return;
    }
    world[row][col].setWall();
    updateUI();
  }
  protected void removeWall(int row, int col) {
    if (stopped) {
      return;
    }
    world[row][col].unsetWall();
    updateUI();
  }
  protected boolean isAllowedRow(int row) {
    return row > 0 && row < HEIGHT - 1;
  }
  protected boolean isAllowedCol(int col) {
    return col > 0 && col < WIDTH - 1;
  }
  private void updateUI() {
    for (int i = 0; i < HEIGHT; i++) {
      for (int j = 0; j < WIDTH; j++) {
        Color cell = Color.WHITE;
        Cell worldCell = world[i][j];
        Icon karelIcon = null;

        if (worldCell.isRobot()) {
          cell = Color.LIGHT_GRAY;
          switch (direction) {
            case north:
              karelIcon = karelIconNorth;
              break;
            case east:
              karelIcon = karelIconEast;
              break;
            case south:
              karelIcon = karelIconSouth;
              break;
            default:
              karelIcon = karelIconWest;
          }
        }
        if (worldCell.isWall()) {
          cell = Color.RED;
        }
        final VisualCell currentVisual = visuals[i][j];
        final Color cellValue = cell;
        int marks = worldCell.getMarks();
        final String marksCaption = (marks > 0 ? "" + marks : "");
        final Icon cellIcon = karelIcon;
        final boolean isStopped = stopped;
        try {
          SwingUtilities.invokeAndWait(new Runnable() {
            @Override
            public void run() {
              if (isStopped) {
                frame.setTitle("Robot - STOPPED");
              }
              currentVisual.setBackground(cellValue);
              currentVisual.setIcon(cellIcon);
              currentVisual.setMarks(marksCaption);
              currentVisual.setFont(new Font(currentVisual.getFont().getName(), Font.BOLD, 18));
            }
          });
        } catch (Exception e) {
          throw new RuntimeException(e);
        }

      }
    }
  }
}
