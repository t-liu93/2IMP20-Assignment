// automatically generated by Xtext
grammar glt.RobotDSL with org.eclipse.xtext.common.Terminals

import "robotDSLEcore" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Script returns Script:
	{Script}
	'Script'
	name=EString
	'{'
		('statements' '{' statements+=Statements ( "," statements+=Statements)* '}' )?
	'}';

Statements returns Statements:
	Statements_Impl | CommandStatement_Impl | IfStatement | WhileStatement | RepeatStatement | Step | TurnLeft | Drop | Pick | TraceMessage | Comment | BuildStatements_Impl | DestroyWall | PickMark | DropMark | BuildWall | RunningStatements_Impl;

LogicalExps returns LogicalExps:
	LogicalExps_Impl | Full | Mark | WallAhead | Heading | SingleLogalExp_Impl | BinaryLogicalExp;

RunningStatements returns RunningStatements:
	RunningStatements_Impl | CommandStatement_Impl | IfStatement | WhileStatement | RepeatStatement | Step | TurnLeft | Drop | Pick | TraceMessage | Comment;

CommandStatement returns CommandStatement:
	CommandStatement_Impl | Step | TurnLeft | Drop | Pick | TraceMessage | Comment;


Binaries returns Binaries:
	Binaries_Impl | And | Or;

SingleLogalExp returns SingleLogalExp:
	SingleLogalExp_Impl | Full | Mark | WallAhead | Heading;

EString returns ecore::EString:
	STRING | ID;

Statements_Impl returns Statements:
	{Statements}
	'Statements'
	;

CommandStatement_Impl returns CommandStatement:
	{CommandStatement}
	'CommandStatement'
	;

IfStatement returns IfStatement:
	'IfStatement'
	'{'
		'logicalexps' logicalexps=LogicalExps
		('runningstatements' '{' runningstatements+=RunningStatements ( "," runningstatements+=RunningStatements)* '}' )?
	'}';

WhileStatement returns WhileStatement:
	'WhileStatement'
	'{'
		'logicalexps' logicalexps=LogicalExps
		('runningstatements' '{' runningstatements+=RunningStatements ( "," runningstatements+=RunningStatements)* '}' )?
	'}';

RepeatStatement returns RepeatStatement:
	{RepeatStatement}
	'RepeatStatement'
	'{'
		('time' time=EInt)?
		('commandstatement' '{' commandstatement+=CommandStatement ( "," commandstatement+=CommandStatement)* '}' )?
	'}';

Step returns Step:
	{Step}
	'Step'
	;

TurnLeft returns TurnLeft:
	{TurnLeft}
	'TurnLeft'
	;

Drop returns Drop:
	{Drop}
	'Drop'
	;

Pick returns Pick:
	{Pick}
	'Pick'
	;

TraceMessage returns TraceMessage:
	{TraceMessage}
	'TraceMessage'
	'{'
		('message' message=EString)?
	'}';

Comment returns Comment:
	{Comment}
	'Comment'
	'{'
		('comment' comment=EString)?
	'}';

BuildStatements_Impl returns BuildStatements:
	{BuildStatements}
	'BuildStatements'
	;

DestroyWall returns DestroyWall:
	{DestroyWall}
	'DestroyWall'
	'{'
		('row' row=EInt)?
		('column' column=EInt)?
	'}';

PickMark returns PickMark:
	{PickMark}
	'PickMark'
	'{'
		('row' row=EInt)?
		('column' column=EInt)?
	'}';

DropMark returns DropMark:
	{DropMark}
	'DropMark'
	'{'
		('row' row=EInt)?
		('column' column=EInt)?
	'}';

BuildWall returns BuildWall:
	{BuildWall}
	'BuildWall'
	'{'
		('row' row=EInt)?
		('column' column=EInt)?
	'}';

RunningStatements_Impl returns RunningStatements:
	{RunningStatements}
	'RunningStatements'
	;

LogicalExps_Impl returns LogicalExps:
	{LogicalExps}
	'LogicalExps'
	;

Full returns Full:
	{Full}
	'Full'
	'{'
		('not' not=Not)?
	'}';

Mark returns Mark:
	{Mark}
	'Mark'
	'{'
		('not' not=Not)?
	'}';

WallAhead returns WallAhead:
	{WallAhead}
	'WallAhead'
	'{'
		('not' not=Not)?
	'}';

Heading returns Heading:
	{Heading}
	'Heading'
	'{'
		('direction' direction=Directions)?
		('not' not=Not)?
	'}';

SingleLogalExp_Impl returns SingleLogalExp:
	{SingleLogalExp}
	'SingleLogalExp'
	;

BinaryLogicalExp returns BinaryLogicalExp:
	'BinaryLogicalExp'
	'{'
		'binaries' '{' binaries+=Binaries ( "," binaries+=Binaries)* '}' 
		'singlelogalexp' '{' singlelogalexp+=SingleLogalExp ( "," singlelogalexp+=SingleLogalExp)* '}' 
	'}';

Not returns Not:
	{Not}
	'Not'
	;

enum Directions returns Directions:
				south = 'south' | north = 'north' | west = 'west' | east = 'east';

Binaries_Impl returns Binaries:
	{Binaries}
	'Binaries'
	;

And returns And:
	{And}
	'And'
	;

Or returns Or:
	{Or}
	'Or'
	;

EInt returns ecore::EInt:
	'-'? INT;
