/*
 * generated by Xtext 2.11.0
 */
package glt.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class RobotDSLGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ScriptElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Script");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cScriptAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cScriptKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameNAMETerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cRunsKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cAsKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cStatementsAssignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final RuleCall cStatementsStatementsParserRuleCall_5_0_0 = (RuleCall)cStatementsAssignment_5_0.eContents().get(0);
		private final Assignment cStatementsAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cStatementsStatementsParserRuleCall_5_1_0 = (RuleCall)cStatementsAssignment_5_1.eContents().get(0);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//Script:
		//	{Script}
		//	'Script'
		//	name=NAME
		//	'runs'
		//	'as' (statements+=Statements statements+=Statements*)?
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//{Script} 'Script' name=NAME 'runs' 'as' (statements+=Statements statements+=Statements*)? 'end'
		public Group getGroup() { return cGroup; }
		
		//{Script}
		public Action getScriptAction_0() { return cScriptAction_0; }
		
		//'Script'
		public Keyword getScriptKeyword_1() { return cScriptKeyword_1; }
		
		//name=NAME
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//NAME
		public RuleCall getNameNAMETerminalRuleCall_2_0() { return cNameNAMETerminalRuleCall_2_0; }
		
		//'runs'
		public Keyword getRunsKeyword_3() { return cRunsKeyword_3; }
		
		//'as'
		public Keyword getAsKeyword_4() { return cAsKeyword_4; }
		
		//(statements+=Statements statements+=Statements*)?
		public Group getGroup_5() { return cGroup_5; }
		
		//statements+=Statements
		public Assignment getStatementsAssignment_5_0() { return cStatementsAssignment_5_0; }
		
		//Statements
		public RuleCall getStatementsStatementsParserRuleCall_5_0_0() { return cStatementsStatementsParserRuleCall_5_0_0; }
		
		//statements+=Statements*
		public Assignment getStatementsAssignment_5_1() { return cStatementsAssignment_5_1; }
		
		//Statements
		public RuleCall getStatementsStatementsParserRuleCall_5_1_0() { return cStatementsStatementsParserRuleCall_5_1_0; }
		
		//'end'
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }
	}
	public class StatementsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Statements");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIfStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cWhileStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRepeatStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cStepParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cTurnLeftParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cDropParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cPickParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cTraceMessageParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cCommentParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cDestroyWallParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cPickMarkParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cDropMarkParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cBuildWallParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		
		//Statements:
		//	IfStatement | WhileStatement | RepeatStatement | Step | TurnLeft | Drop | Pick | TraceMessage | Comment | DestroyWall
		//	| PickMark | DropMark | BuildWall;
		@Override public ParserRule getRule() { return rule; }
		
		//IfStatement | WhileStatement | RepeatStatement | Step | TurnLeft | Drop | Pick | TraceMessage | Comment | DestroyWall |
		//PickMark | DropMark | BuildWall
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IfStatement
		public RuleCall getIfStatementParserRuleCall_0() { return cIfStatementParserRuleCall_0; }
		
		//WhileStatement
		public RuleCall getWhileStatementParserRuleCall_1() { return cWhileStatementParserRuleCall_1; }
		
		//RepeatStatement
		public RuleCall getRepeatStatementParserRuleCall_2() { return cRepeatStatementParserRuleCall_2; }
		
		//Step
		public RuleCall getStepParserRuleCall_3() { return cStepParserRuleCall_3; }
		
		//TurnLeft
		public RuleCall getTurnLeftParserRuleCall_4() { return cTurnLeftParserRuleCall_4; }
		
		//Drop
		public RuleCall getDropParserRuleCall_5() { return cDropParserRuleCall_5; }
		
		//Pick
		public RuleCall getPickParserRuleCall_6() { return cPickParserRuleCall_6; }
		
		//TraceMessage
		public RuleCall getTraceMessageParserRuleCall_7() { return cTraceMessageParserRuleCall_7; }
		
		//Comment
		public RuleCall getCommentParserRuleCall_8() { return cCommentParserRuleCall_8; }
		
		//DestroyWall
		public RuleCall getDestroyWallParserRuleCall_9() { return cDestroyWallParserRuleCall_9; }
		
		//PickMark
		public RuleCall getPickMarkParserRuleCall_10() { return cPickMarkParserRuleCall_10; }
		
		//DropMark
		public RuleCall getDropMarkParserRuleCall_11() { return cDropMarkParserRuleCall_11; }
		
		//BuildWall
		public RuleCall getBuildWallParserRuleCall_12() { return cBuildWallParserRuleCall_12; }
	}
	public class LogicalExpsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.LogicalExps");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFullParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMarkParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cWallAheadParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cHeadingParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cBinaryLogicalExpParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//LogicalExps:
		//	Full | Mark | WallAhead | Heading | BinaryLogicalExp;
		@Override public ParserRule getRule() { return rule; }
		
		//Full | Mark | WallAhead | Heading | BinaryLogicalExp
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Full
		public RuleCall getFullParserRuleCall_0() { return cFullParserRuleCall_0; }
		
		//Mark
		public RuleCall getMarkParserRuleCall_1() { return cMarkParserRuleCall_1; }
		
		//WallAhead
		public RuleCall getWallAheadParserRuleCall_2() { return cWallAheadParserRuleCall_2; }
		
		//Heading
		public RuleCall getHeadingParserRuleCall_3() { return cHeadingParserRuleCall_3; }
		
		//BinaryLogicalExp
		public RuleCall getBinaryLogicalExpParserRuleCall_4() { return cBinaryLogicalExpParserRuleCall_4; }
	}
	public class RunningStatementsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.RunningStatements");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIfStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cWhileStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRepeatStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cStepParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cTurnLeftParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cDropParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cPickParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cTraceMessageParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cCommentParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		
		//RunningStatements:
		//	IfStatement | WhileStatement | RepeatStatement | Step | TurnLeft | Drop | Pick | TraceMessage | Comment;
		@Override public ParserRule getRule() { return rule; }
		
		//IfStatement | WhileStatement | RepeatStatement | Step | TurnLeft | Drop | Pick | TraceMessage | Comment
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IfStatement
		public RuleCall getIfStatementParserRuleCall_0() { return cIfStatementParserRuleCall_0; }
		
		//WhileStatement
		public RuleCall getWhileStatementParserRuleCall_1() { return cWhileStatementParserRuleCall_1; }
		
		//RepeatStatement
		public RuleCall getRepeatStatementParserRuleCall_2() { return cRepeatStatementParserRuleCall_2; }
		
		//Step
		public RuleCall getStepParserRuleCall_3() { return cStepParserRuleCall_3; }
		
		//TurnLeft
		public RuleCall getTurnLeftParserRuleCall_4() { return cTurnLeftParserRuleCall_4; }
		
		//Drop
		public RuleCall getDropParserRuleCall_5() { return cDropParserRuleCall_5; }
		
		//Pick
		public RuleCall getPickParserRuleCall_6() { return cPickParserRuleCall_6; }
		
		//TraceMessage
		public RuleCall getTraceMessageParserRuleCall_7() { return cTraceMessageParserRuleCall_7; }
		
		//Comment
		public RuleCall getCommentParserRuleCall_8() { return cCommentParserRuleCall_8; }
	}
	public class CommandStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.CommandStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStepParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTurnLeftParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cDropParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cPickParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cTraceMessageParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cCommentParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//CommandStatement:
		//	Step | TurnLeft | Drop | Pick | TraceMessage | Comment;
		@Override public ParserRule getRule() { return rule; }
		
		//Step | TurnLeft | Drop | Pick | TraceMessage | Comment
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Step
		public RuleCall getStepParserRuleCall_0() { return cStepParserRuleCall_0; }
		
		//TurnLeft
		public RuleCall getTurnLeftParserRuleCall_1() { return cTurnLeftParserRuleCall_1; }
		
		//Drop
		public RuleCall getDropParserRuleCall_2() { return cDropParserRuleCall_2; }
		
		//Pick
		public RuleCall getPickParserRuleCall_3() { return cPickParserRuleCall_3; }
		
		//TraceMessage
		public RuleCall getTraceMessageParserRuleCall_4() { return cTraceMessageParserRuleCall_4; }
		
		//Comment
		public RuleCall getCommentParserRuleCall_5() { return cCommentParserRuleCall_5; }
	}
	public class BinariesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Binaries");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAndParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cOrParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Binaries:
		//	And | Or;
		@Override public ParserRule getRule() { return rule; }
		
		//And | Or
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//And
		public RuleCall getAndParserRuleCall_0() { return cAndParserRuleCall_0; }
		
		//Or
		public RuleCall getOrParserRuleCall_1() { return cOrParserRuleCall_1; }
	}
	public class SingleLogalExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.SingleLogalExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFullParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMarkParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cWallAheadParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cHeadingParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//SingleLogalExp:
		//	Full | Mark | WallAhead | Heading;
		@Override public ParserRule getRule() { return rule; }
		
		//Full | Mark | WallAhead | Heading
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Full
		public RuleCall getFullParserRuleCall_0() { return cFullParserRuleCall_0; }
		
		//Mark
		public RuleCall getMarkParserRuleCall_1() { return cMarkParserRuleCall_1; }
		
		//WallAhead
		public RuleCall getWallAheadParserRuleCall_2() { return cWallAheadParserRuleCall_2; }
		
		//Heading
		public RuleCall getHeadingParserRuleCall_3() { return cHeadingParserRuleCall_3; }
	}
	public class EStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.EString");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSTRINGTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EString:
		//	STRING | ID;
		@Override public ParserRule getRule() { return rule; }
		
		//STRING | ID
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//STRING
		public RuleCall getSTRINGTerminalRuleCall_0() { return cSTRINGTerminalRuleCall_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1() { return cIDTerminalRuleCall_1; }
	}
	public class Statements_ImplElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Statements_Impl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStatementsAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cStatementsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Statements_Impl Statements:
		//	{Statements}
		//	'Statements';
		@Override public ParserRule getRule() { return rule; }
		
		//{Statements} 'Statements'
		public Group getGroup() { return cGroup; }
		
		//{Statements}
		public Action getStatementsAction_0() { return cStatementsAction_0; }
		
		//'Statements'
		public Keyword getStatementsKeyword_1() { return cStatementsKeyword_1; }
	}
	public class CommandStatement_ImplElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.CommandStatement_Impl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCommandStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cCommandStatementKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//CommandStatement_Impl CommandStatement:
		//	{CommandStatement}
		//	'CommandStatement';
		@Override public ParserRule getRule() { return rule; }
		
		//{CommandStatement} 'CommandStatement'
		public Group getGroup() { return cGroup; }
		
		//{CommandStatement}
		public Action getCommandStatementAction_0() { return cCommandStatementAction_0; }
		
		//'CommandStatement'
		public Keyword getCommandStatementKeyword_1() { return cCommandStatementKeyword_1; }
	}
	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIfStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLogicalexpsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLogicalexpsLogicalExpsParserRuleCall_2_0 = (RuleCall)cLogicalexpsAssignment_2.eContents().get(0);
		private final Keyword cDoKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cRunningstatementsAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cRunningstatementsRunningStatementsParserRuleCall_4_0_0 = (RuleCall)cRunningstatementsAssignment_4_0.eContents().get(0);
		private final Assignment cRunningstatementsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cRunningstatementsRunningStatementsParserRuleCall_4_1_0 = (RuleCall)cRunningstatementsAssignment_4_1.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cElseAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cElseElseParserRuleCall_6_0 = (RuleCall)cElseAssignment_6.eContents().get(0);
		
		//IfStatement:
		//	{IfStatement}
		//	'if'
		//	logicalexps=LogicalExps
		//	'do' (runningstatements+=RunningStatements runningstatements+=RunningStatements*)?
		//	'end'
		//	else=Else?;
		@Override public ParserRule getRule() { return rule; }
		
		//{IfStatement} 'if' logicalexps=LogicalExps 'do' (runningstatements+=RunningStatements
		//runningstatements+=RunningStatements*)? 'end' else=Else?
		public Group getGroup() { return cGroup; }
		
		//{IfStatement}
		public Action getIfStatementAction_0() { return cIfStatementAction_0; }
		
		//'if'
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }
		
		//logicalexps=LogicalExps
		public Assignment getLogicalexpsAssignment_2() { return cLogicalexpsAssignment_2; }
		
		//LogicalExps
		public RuleCall getLogicalexpsLogicalExpsParserRuleCall_2_0() { return cLogicalexpsLogicalExpsParserRuleCall_2_0; }
		
		//'do'
		public Keyword getDoKeyword_3() { return cDoKeyword_3; }
		
		//(runningstatements+=RunningStatements runningstatements+=RunningStatements*)?
		public Group getGroup_4() { return cGroup_4; }
		
		//runningstatements+=RunningStatements
		public Assignment getRunningstatementsAssignment_4_0() { return cRunningstatementsAssignment_4_0; }
		
		//RunningStatements
		public RuleCall getRunningstatementsRunningStatementsParserRuleCall_4_0_0() { return cRunningstatementsRunningStatementsParserRuleCall_4_0_0; }
		
		//runningstatements+=RunningStatements*
		public Assignment getRunningstatementsAssignment_4_1() { return cRunningstatementsAssignment_4_1; }
		
		//RunningStatements
		public RuleCall getRunningstatementsRunningStatementsParserRuleCall_4_1_0() { return cRunningstatementsRunningStatementsParserRuleCall_4_1_0; }
		
		//'end'
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }
		
		//else=Else?
		public Assignment getElseAssignment_6() { return cElseAssignment_6; }
		
		//Else
		public RuleCall getElseElseParserRuleCall_6_0() { return cElseElseParserRuleCall_6_0; }
	}
	public class WhileStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.WhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWhileStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWhileKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLogicalexpsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLogicalexpsLogicalExpsParserRuleCall_2_0 = (RuleCall)cLogicalexpsAssignment_2.eContents().get(0);
		private final Keyword cDoKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cRunningstatementsAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cRunningstatementsRunningStatementsParserRuleCall_4_0_0 = (RuleCall)cRunningstatementsAssignment_4_0.eContents().get(0);
		private final Assignment cRunningstatementsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cRunningstatementsRunningStatementsParserRuleCall_4_1_0 = (RuleCall)cRunningstatementsAssignment_4_1.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//WhileStatement:
		//	{WhileStatement}
		//	'while'
		//	logicalexps=LogicalExps
		//	'do' (runningstatements+=RunningStatements runningstatements+=RunningStatements*)?
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//{WhileStatement} 'while' logicalexps=LogicalExps 'do' (runningstatements+=RunningStatements
		//runningstatements+=RunningStatements*)? 'end'
		public Group getGroup() { return cGroup; }
		
		//{WhileStatement}
		public Action getWhileStatementAction_0() { return cWhileStatementAction_0; }
		
		//'while'
		public Keyword getWhileKeyword_1() { return cWhileKeyword_1; }
		
		//logicalexps=LogicalExps
		public Assignment getLogicalexpsAssignment_2() { return cLogicalexpsAssignment_2; }
		
		//LogicalExps
		public RuleCall getLogicalexpsLogicalExpsParserRuleCall_2_0() { return cLogicalexpsLogicalExpsParserRuleCall_2_0; }
		
		//'do'
		public Keyword getDoKeyword_3() { return cDoKeyword_3; }
		
		//(runningstatements+=RunningStatements runningstatements+=RunningStatements*)?
		public Group getGroup_4() { return cGroup_4; }
		
		//runningstatements+=RunningStatements
		public Assignment getRunningstatementsAssignment_4_0() { return cRunningstatementsAssignment_4_0; }
		
		//RunningStatements
		public RuleCall getRunningstatementsRunningStatementsParserRuleCall_4_0_0() { return cRunningstatementsRunningStatementsParserRuleCall_4_0_0; }
		
		//runningstatements+=RunningStatements*
		public Assignment getRunningstatementsAssignment_4_1() { return cRunningstatementsAssignment_4_1; }
		
		//RunningStatements
		public RuleCall getRunningstatementsRunningStatementsParserRuleCall_4_1_0() { return cRunningstatementsRunningStatementsParserRuleCall_4_1_0; }
		
		//'end'
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }
	}
	public class RepeatStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.RepeatStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRepeatStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cRepeatKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTimeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTimeEIntParserRuleCall_2_0 = (RuleCall)cTimeAssignment_2.eContents().get(0);
		private final Keyword cTimesKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cCommandstatementAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cCommandstatementCommandStatementParserRuleCall_4_0_0 = (RuleCall)cCommandstatementAssignment_4_0.eContents().get(0);
		private final Assignment cCommandstatementAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cCommandstatementCommandStatementParserRuleCall_4_1_0 = (RuleCall)cCommandstatementAssignment_4_1.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//RepeatStatement:
		//	{RepeatStatement}
		//	'repeat'
		//	time=EInt
		//	'times' (commandstatement+=CommandStatement commandstatement+=CommandStatement*)?
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//{RepeatStatement} 'repeat' time=EInt 'times' (commandstatement+=CommandStatement commandstatement+=CommandStatement*)?
		//'end'
		public Group getGroup() { return cGroup; }
		
		//{RepeatStatement}
		public Action getRepeatStatementAction_0() { return cRepeatStatementAction_0; }
		
		//'repeat'
		public Keyword getRepeatKeyword_1() { return cRepeatKeyword_1; }
		
		//time=EInt
		public Assignment getTimeAssignment_2() { return cTimeAssignment_2; }
		
		//EInt
		public RuleCall getTimeEIntParserRuleCall_2_0() { return cTimeEIntParserRuleCall_2_0; }
		
		//'times'
		public Keyword getTimesKeyword_3() { return cTimesKeyword_3; }
		
		//(commandstatement+=CommandStatement commandstatement+=CommandStatement*)?
		public Group getGroup_4() { return cGroup_4; }
		
		//commandstatement+=CommandStatement
		public Assignment getCommandstatementAssignment_4_0() { return cCommandstatementAssignment_4_0; }
		
		//CommandStatement
		public RuleCall getCommandstatementCommandStatementParserRuleCall_4_0_0() { return cCommandstatementCommandStatementParserRuleCall_4_0_0; }
		
		//commandstatement+=CommandStatement*
		public Assignment getCommandstatementAssignment_4_1() { return cCommandstatementAssignment_4_1; }
		
		//CommandStatement
		public RuleCall getCommandstatementCommandStatementParserRuleCall_4_1_0() { return cCommandstatementCommandStatementParserRuleCall_4_1_0; }
		
		//'end'
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }
	}
	public class StepElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Step");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStepAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cStepKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Step:
		//	{Step}
		//	'step';
		@Override public ParserRule getRule() { return rule; }
		
		//{Step} 'step'
		public Group getGroup() { return cGroup; }
		
		//{Step}
		public Action getStepAction_0() { return cStepAction_0; }
		
		//'step'
		public Keyword getStepKeyword_1() { return cStepKeyword_1; }
	}
	public class TurnLeftElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.TurnLeft");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTurnLeftAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTurnLeftKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//TurnLeft:
		//	{TurnLeft}
		//	'turnLeft';
		@Override public ParserRule getRule() { return rule; }
		
		//{TurnLeft} 'turnLeft'
		public Group getGroup() { return cGroup; }
		
		//{TurnLeft}
		public Action getTurnLeftAction_0() { return cTurnLeftAction_0; }
		
		//'turnLeft'
		public Keyword getTurnLeftKeyword_1() { return cTurnLeftKeyword_1; }
	}
	public class DropElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Drop");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDropAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cDropKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Drop:
		//	{Drop}
		//	'drop';
		@Override public ParserRule getRule() { return rule; }
		
		//{Drop} 'drop'
		public Group getGroup() { return cGroup; }
		
		//{Drop}
		public Action getDropAction_0() { return cDropAction_0; }
		
		//'drop'
		public Keyword getDropKeyword_1() { return cDropKeyword_1; }
	}
	public class PickElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Pick");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPickAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cPickKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Pick:
		//	{Pick}
		//	'pick';
		@Override public ParserRule getRule() { return rule; }
		
		//{Pick} 'pick'
		public Group getGroup() { return cGroup; }
		
		//{Pick}
		public Action getPickAction_0() { return cPickAction_0; }
		
		//'pick'
		public Keyword getPickKeyword_1() { return cPickKeyword_1; }
	}
	public class TraceMessageElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.TraceMessage");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTraceMessageAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTraceKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cMessageAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMessageMessagesParserRuleCall_2_0 = (RuleCall)cMessageAssignment_2.eContents().get(0);
		
		//TraceMessage:
		//	{TraceMessage}
		//	'trace'
		//	message=Messages;
		@Override public ParserRule getRule() { return rule; }
		
		//{TraceMessage} 'trace' message=Messages
		public Group getGroup() { return cGroup; }
		
		//{TraceMessage}
		public Action getTraceMessageAction_0() { return cTraceMessageAction_0; }
		
		//'trace'
		public Keyword getTraceKeyword_1() { return cTraceKeyword_1; }
		
		//message=Messages
		public Assignment getMessageAssignment_2() { return cMessageAssignment_2; }
		
		//Messages
		public RuleCall getMessageMessagesParserRuleCall_2_0() { return cMessageMessagesParserRuleCall_2_0; }
	}
	public class CommentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Comment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCommentAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCommentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCommentCOMMENTSTerminalRuleCall_1_0 = (RuleCall)cCommentAssignment_1.eContents().get(0);
		
		//Comment:
		//	{Comment} comment=COMMENTS;
		@Override public ParserRule getRule() { return rule; }
		
		//{Comment} comment=COMMENTS
		public Group getGroup() { return cGroup; }
		
		//{Comment}
		public Action getCommentAction_0() { return cCommentAction_0; }
		
		//comment=COMMENTS
		public Assignment getCommentAssignment_1() { return cCommentAssignment_1; }
		
		//COMMENTS
		public RuleCall getCommentCOMMENTSTerminalRuleCall_1_0() { return cCommentCOMMENTSTerminalRuleCall_1_0; }
	}
	public class BuildStatements_ImplElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.BuildStatements_Impl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBuildStatementsAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cBuildStatementsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//BuildStatements_Impl BuildStatements:
		//	{BuildStatements}
		//	'BuildStatements';
		@Override public ParserRule getRule() { return rule; }
		
		//{BuildStatements} 'BuildStatements'
		public Group getGroup() { return cGroup; }
		
		//{BuildStatements}
		public Action getBuildStatementsAction_0() { return cBuildStatementsAction_0; }
		
		//'BuildStatements'
		public Keyword getBuildStatementsKeyword_1() { return cBuildStatementsKeyword_1; }
	}
	public class DestroyWallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.DestroyWall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDestroyWallAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cDestroyWallKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cAtKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRowKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRowAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRowINTTerminalRuleCall_4_0 = (RuleCall)cRowAssignment_4.eContents().get(0);
		private final Keyword cColKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cColumnAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cColumnINTTerminalRuleCall_6_0 = (RuleCall)cColumnAssignment_6.eContents().get(0);
		
		//DestroyWall:
		//	{DestroyWall}
		//	'destroyWall'
		//	'at'
		//	'row:'
		//	row=INT
		//	'col:'
		//	column=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//{DestroyWall} 'destroyWall' 'at' 'row:' row=INT 'col:' column=INT
		public Group getGroup() { return cGroup; }
		
		//{DestroyWall}
		public Action getDestroyWallAction_0() { return cDestroyWallAction_0; }
		
		//'destroyWall'
		public Keyword getDestroyWallKeyword_1() { return cDestroyWallKeyword_1; }
		
		//'at'
		public Keyword getAtKeyword_2() { return cAtKeyword_2; }
		
		//'row:'
		public Keyword getRowKeyword_3() { return cRowKeyword_3; }
		
		//row=INT
		public Assignment getRowAssignment_4() { return cRowAssignment_4; }
		
		//INT
		public RuleCall getRowINTTerminalRuleCall_4_0() { return cRowINTTerminalRuleCall_4_0; }
		
		//'col:'
		public Keyword getColKeyword_5() { return cColKeyword_5; }
		
		//column=INT
		public Assignment getColumnAssignment_6() { return cColumnAssignment_6; }
		
		//INT
		public RuleCall getColumnINTTerminalRuleCall_6_0() { return cColumnINTTerminalRuleCall_6_0; }
	}
	public class PickMarkElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.PickMark");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPickMarkAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cPickMarkKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cAtKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRowKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRowAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRowINTTerminalRuleCall_4_0 = (RuleCall)cRowAssignment_4.eContents().get(0);
		private final Keyword cColKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cColumnAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cColumnINTTerminalRuleCall_6_0 = (RuleCall)cColumnAssignment_6.eContents().get(0);
		
		//PickMark:
		//	{PickMark}
		//	'pickMark'
		//	'at'
		//	'row:'
		//	row=INT
		//	'col:'
		//	column=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//{PickMark} 'pickMark' 'at' 'row:' row=INT 'col:' column=INT
		public Group getGroup() { return cGroup; }
		
		//{PickMark}
		public Action getPickMarkAction_0() { return cPickMarkAction_0; }
		
		//'pickMark'
		public Keyword getPickMarkKeyword_1() { return cPickMarkKeyword_1; }
		
		//'at'
		public Keyword getAtKeyword_2() { return cAtKeyword_2; }
		
		//'row:'
		public Keyword getRowKeyword_3() { return cRowKeyword_3; }
		
		//row=INT
		public Assignment getRowAssignment_4() { return cRowAssignment_4; }
		
		//INT
		public RuleCall getRowINTTerminalRuleCall_4_0() { return cRowINTTerminalRuleCall_4_0; }
		
		//'col:'
		public Keyword getColKeyword_5() { return cColKeyword_5; }
		
		//column=INT
		public Assignment getColumnAssignment_6() { return cColumnAssignment_6; }
		
		//INT
		public RuleCall getColumnINTTerminalRuleCall_6_0() { return cColumnINTTerminalRuleCall_6_0; }
	}
	public class DropMarkElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.DropMark");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDropMarkAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cDropMarkKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cAtKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRowKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRowAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRowINTTerminalRuleCall_4_0 = (RuleCall)cRowAssignment_4.eContents().get(0);
		private final Keyword cColKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cColumnAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cColumnINTTerminalRuleCall_6_0 = (RuleCall)cColumnAssignment_6.eContents().get(0);
		
		//DropMark:
		//	{DropMark}
		//	'dropMark'
		//	'at'
		//	'row:'
		//	row=INT
		//	'col:'
		//	column=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//{DropMark} 'dropMark' 'at' 'row:' row=INT 'col:' column=INT
		public Group getGroup() { return cGroup; }
		
		//{DropMark}
		public Action getDropMarkAction_0() { return cDropMarkAction_0; }
		
		//'dropMark'
		public Keyword getDropMarkKeyword_1() { return cDropMarkKeyword_1; }
		
		//'at'
		public Keyword getAtKeyword_2() { return cAtKeyword_2; }
		
		//'row:'
		public Keyword getRowKeyword_3() { return cRowKeyword_3; }
		
		//row=INT
		public Assignment getRowAssignment_4() { return cRowAssignment_4; }
		
		//INT
		public RuleCall getRowINTTerminalRuleCall_4_0() { return cRowINTTerminalRuleCall_4_0; }
		
		//'col:'
		public Keyword getColKeyword_5() { return cColKeyword_5; }
		
		//column=INT
		public Assignment getColumnAssignment_6() { return cColumnAssignment_6; }
		
		//INT
		public RuleCall getColumnINTTerminalRuleCall_6_0() { return cColumnINTTerminalRuleCall_6_0; }
	}
	public class BuildWallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.BuildWall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBuildWallAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cBuildWallKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cAtKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRowKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRowAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRowINTTerminalRuleCall_4_0 = (RuleCall)cRowAssignment_4.eContents().get(0);
		private final Keyword cColKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cColumnAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cColumnINTTerminalRuleCall_6_0 = (RuleCall)cColumnAssignment_6.eContents().get(0);
		
		//BuildWall:
		//	{BuildWall}
		//	'buildWall'
		//	'at'
		//	'row:'
		//	row=INT
		//	'col:'
		//	column=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//{BuildWall} 'buildWall' 'at' 'row:' row=INT 'col:' column=INT
		public Group getGroup() { return cGroup; }
		
		//{BuildWall}
		public Action getBuildWallAction_0() { return cBuildWallAction_0; }
		
		//'buildWall'
		public Keyword getBuildWallKeyword_1() { return cBuildWallKeyword_1; }
		
		//'at'
		public Keyword getAtKeyword_2() { return cAtKeyword_2; }
		
		//'row:'
		public Keyword getRowKeyword_3() { return cRowKeyword_3; }
		
		//row=INT
		public Assignment getRowAssignment_4() { return cRowAssignment_4; }
		
		//INT
		public RuleCall getRowINTTerminalRuleCall_4_0() { return cRowINTTerminalRuleCall_4_0; }
		
		//'col:'
		public Keyword getColKeyword_5() { return cColKeyword_5; }
		
		//column=INT
		public Assignment getColumnAssignment_6() { return cColumnAssignment_6; }
		
		//INT
		public RuleCall getColumnINTTerminalRuleCall_6_0() { return cColumnINTTerminalRuleCall_6_0; }
	}
	public class RunningStatements_ImplElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.RunningStatements_Impl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRunningStatementsAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cRunningStatementsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//RunningStatements_Impl RunningStatements:
		//	{RunningStatements}
		//	'RunningStatements';
		@Override public ParserRule getRule() { return rule; }
		
		//{RunningStatements} 'RunningStatements'
		public Group getGroup() { return cGroup; }
		
		//{RunningStatements}
		public Action getRunningStatementsAction_0() { return cRunningStatementsAction_0; }
		
		//'RunningStatements'
		public Keyword getRunningStatementsKeyword_1() { return cRunningStatementsKeyword_1; }
	}
	public class LogicalExps_ImplElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.LogicalExps_Impl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLogicalExpsAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLogicalExpsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//LogicalExps_Impl LogicalExps:
		//	{LogicalExps}
		//	'LogicalExps';
		@Override public ParserRule getRule() { return rule; }
		
		//{LogicalExps} 'LogicalExps'
		public Group getGroup() { return cGroup; }
		
		//{LogicalExps}
		public Action getLogicalExpsAction_0() { return cLogicalExpsAction_0; }
		
		//'LogicalExps'
		public Keyword getLogicalExpsKeyword_1() { return cLogicalExpsKeyword_1; }
	}
	public class ElseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Else");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cElseAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cElseKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cDoKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cRunningstatementsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cRunningstatementsRunningStatementsParserRuleCall_3_0_0 = (RuleCall)cRunningstatementsAssignment_3_0.eContents().get(0);
		private final Assignment cRunningstatementsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cRunningstatementsRunningStatementsParserRuleCall_3_1_0 = (RuleCall)cRunningstatementsAssignment_3_1.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Else:
		//	{Else}
		//	'else'
		//	'do' (runningstatements+=RunningStatements runningstatements+=RunningStatements*)?
		//	'end';
		@Override public ParserRule getRule() { return rule; }
		
		//{Else} 'else' 'do' (runningstatements+=RunningStatements runningstatements+=RunningStatements*)? 'end'
		public Group getGroup() { return cGroup; }
		
		//{Else}
		public Action getElseAction_0() { return cElseAction_0; }
		
		//'else'
		public Keyword getElseKeyword_1() { return cElseKeyword_1; }
		
		//'do'
		public Keyword getDoKeyword_2() { return cDoKeyword_2; }
		
		//(runningstatements+=RunningStatements runningstatements+=RunningStatements*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//runningstatements+=RunningStatements
		public Assignment getRunningstatementsAssignment_3_0() { return cRunningstatementsAssignment_3_0; }
		
		//RunningStatements
		public RuleCall getRunningstatementsRunningStatementsParserRuleCall_3_0_0() { return cRunningstatementsRunningStatementsParserRuleCall_3_0_0; }
		
		//runningstatements+=RunningStatements*
		public Assignment getRunningstatementsAssignment_3_1() { return cRunningstatementsAssignment_3_1; }
		
		//RunningStatements
		public RuleCall getRunningstatementsRunningStatementsParserRuleCall_3_1_0() { return cRunningstatementsRunningStatementsParserRuleCall_3_1_0; }
		
		//'end'
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }
	}
	public class FullElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Full");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFullAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNotAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNotNotParserRuleCall_1_0 = (RuleCall)cNotAssignment_1.eContents().get(0);
		private final Keyword cFullKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Full:
		//	{Full} not=Not?
		//	'full';
		@Override public ParserRule getRule() { return rule; }
		
		//{Full} not=Not? 'full'
		public Group getGroup() { return cGroup; }
		
		//{Full}
		public Action getFullAction_0() { return cFullAction_0; }
		
		//not=Not?
		public Assignment getNotAssignment_1() { return cNotAssignment_1; }
		
		//Not
		public RuleCall getNotNotParserRuleCall_1_0() { return cNotNotParserRuleCall_1_0; }
		
		//'full'
		public Keyword getFullKeyword_2() { return cFullKeyword_2; }
	}
	public class MarkElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Mark");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cMarkAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNotAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNotNotParserRuleCall_1_0 = (RuleCall)cNotAssignment_1.eContents().get(0);
		private final Keyword cMarkKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Mark:
		//	{Mark} not=Not?
		//	'mark';
		@Override public ParserRule getRule() { return rule; }
		
		//{Mark} not=Not? 'mark'
		public Group getGroup() { return cGroup; }
		
		//{Mark}
		public Action getMarkAction_0() { return cMarkAction_0; }
		
		//not=Not?
		public Assignment getNotAssignment_1() { return cNotAssignment_1; }
		
		//Not
		public RuleCall getNotNotParserRuleCall_1_0() { return cNotNotParserRuleCall_1_0; }
		
		//'mark'
		public Keyword getMarkKeyword_2() { return cMarkKeyword_2; }
	}
	public class WallAheadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.WallAhead");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWallAheadAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNotAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNotNotParserRuleCall_1_0 = (RuleCall)cNotAssignment_1.eContents().get(0);
		private final Keyword cWallKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cAheadKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//WallAhead:
		//	{WallAhead} not=Not?
		//	'wall'
		//	'ahead';
		@Override public ParserRule getRule() { return rule; }
		
		//{WallAhead} not=Not? 'wall' 'ahead'
		public Group getGroup() { return cGroup; }
		
		//{WallAhead}
		public Action getWallAheadAction_0() { return cWallAheadAction_0; }
		
		//not=Not?
		public Assignment getNotAssignment_1() { return cNotAssignment_1; }
		
		//Not
		public RuleCall getNotNotParserRuleCall_1_0() { return cNotNotParserRuleCall_1_0; }
		
		//'wall'
		public Keyword getWallKeyword_2() { return cWallKeyword_2; }
		
		//'ahead'
		public Keyword getAheadKeyword_3() { return cAheadKeyword_3; }
	}
	public class HeadingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Heading");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cHeadingAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNotAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNotNotParserRuleCall_1_0 = (RuleCall)cNotAssignment_1.eContents().get(0);
		private final Keyword cHeadingKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cDirectionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDirectionDirectionsEnumRuleCall_3_0 = (RuleCall)cDirectionAssignment_3.eContents().get(0);
		
		//Heading:
		//	{Heading} not=Not?
		//	'heading'
		//	direction=Directions;
		@Override public ParserRule getRule() { return rule; }
		
		//{Heading} not=Not? 'heading' direction=Directions
		public Group getGroup() { return cGroup; }
		
		//{Heading}
		public Action getHeadingAction_0() { return cHeadingAction_0; }
		
		//not=Not?
		public Assignment getNotAssignment_1() { return cNotAssignment_1; }
		
		//Not
		public RuleCall getNotNotParserRuleCall_1_0() { return cNotNotParserRuleCall_1_0; }
		
		//'heading'
		public Keyword getHeadingKeyword_2() { return cHeadingKeyword_2; }
		
		//direction=Directions
		public Assignment getDirectionAssignment_3() { return cDirectionAssignment_3; }
		
		//Directions
		public RuleCall getDirectionDirectionsEnumRuleCall_3_0() { return cDirectionDirectionsEnumRuleCall_3_0; }
	}
	public class SingleLogalExp_ImplElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.SingleLogalExp_Impl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSingleLogalExpAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSingleLogalExpKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//SingleLogalExp_Impl SingleLogalExp:
		//	{SingleLogalExp}
		//	'SingleLogalExp';
		@Override public ParserRule getRule() { return rule; }
		
		//{SingleLogalExp} 'SingleLogalExp'
		public Group getGroup() { return cGroup; }
		
		//{SingleLogalExp}
		public Action getSingleLogalExpAction_0() { return cSingleLogalExpAction_0; }
		
		//'SingleLogalExp'
		public Keyword getSingleLogalExpKeyword_1() { return cSingleLogalExpKeyword_1; }
	}
	public class BinaryLogicalExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.BinaryLogicalExp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSinglelogalexpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSinglelogalexpSingleLogalExpParserRuleCall_0_0 = (RuleCall)cSinglelogalexpAssignment_0.eContents().get(0);
		private final Assignment cBinariesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBinariesBinariesParserRuleCall_1_0 = (RuleCall)cBinariesAssignment_1.eContents().get(0);
		
		//BinaryLogicalExp:
		//	singlelogalexp=SingleLogalExp
		//	binaries+=Binaries+;
		@Override public ParserRule getRule() { return rule; }
		
		//singlelogalexp=SingleLogalExp binaries+=Binaries+
		public Group getGroup() { return cGroup; }
		
		//singlelogalexp=SingleLogalExp
		public Assignment getSinglelogalexpAssignment_0() { return cSinglelogalexpAssignment_0; }
		
		//SingleLogalExp
		public RuleCall getSinglelogalexpSingleLogalExpParserRuleCall_0_0() { return cSinglelogalexpSingleLogalExpParserRuleCall_0_0; }
		
		//binaries+=Binaries+
		public Assignment getBinariesAssignment_1() { return cBinariesAssignment_1; }
		
		//Binaries
		public RuleCall getBinariesBinariesParserRuleCall_1_0() { return cBinariesBinariesParserRuleCall_1_0; }
	}
	public class NotElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Not");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNotAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNotKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Not:
		//	{Not}
		//	'not';
		@Override public ParserRule getRule() { return rule; }
		
		//{Not} 'not'
		public Group getGroup() { return cGroup; }
		
		//{Not}
		public Action getNotAction_0() { return cNotAction_0; }
		
		//'not'
		public Keyword getNotKeyword_1() { return cNotKeyword_1; }
	}
	public class Binaries_ImplElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Binaries_Impl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBinariesAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cBinariesKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Binaries_Impl Binaries:
		//	{Binaries}
		//	'Binaries';
		@Override public ParserRule getRule() { return rule; }
		
		//{Binaries} 'Binaries'
		public Group getGroup() { return cGroup; }
		
		//{Binaries}
		public Action getBinariesAction_0() { return cBinariesAction_0; }
		
		//'Binaries'
		public Keyword getBinariesKeyword_1() { return cBinariesKeyword_1; }
	}
	public class AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAndAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cAndKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSinglelogalexpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSinglelogalexpSingleLogalExpParserRuleCall_2_0 = (RuleCall)cSinglelogalexpAssignment_2.eContents().get(0);
		
		//And:
		//	{And}
		//	'and'
		//	singlelogalexp=SingleLogalExp;
		@Override public ParserRule getRule() { return rule; }
		
		//{And} 'and' singlelogalexp=SingleLogalExp
		public Group getGroup() { return cGroup; }
		
		//{And}
		public Action getAndAction_0() { return cAndAction_0; }
		
		//'and'
		public Keyword getAndKeyword_1() { return cAndKeyword_1; }
		
		//singlelogalexp=SingleLogalExp
		public Assignment getSinglelogalexpAssignment_2() { return cSinglelogalexpAssignment_2; }
		
		//SingleLogalExp
		public RuleCall getSinglelogalexpSingleLogalExpParserRuleCall_2_0() { return cSinglelogalexpSingleLogalExpParserRuleCall_2_0; }
	}
	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cOrAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cOrKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSinglelogalexpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSinglelogalexpSingleLogalExpParserRuleCall_2_0 = (RuleCall)cSinglelogalexpAssignment_2.eContents().get(0);
		
		//Or:
		//	{Or}
		//	'or'
		//	singlelogalexp=SingleLogalExp;
		@Override public ParserRule getRule() { return rule; }
		
		//{Or} 'or' singlelogalexp=SingleLogalExp
		public Group getGroup() { return cGroup; }
		
		//{Or}
		public Action getOrAction_0() { return cOrAction_0; }
		
		//'or'
		public Keyword getOrKeyword_1() { return cOrKeyword_1; }
		
		//singlelogalexp=SingleLogalExp
		public Assignment getSinglelogalexpAssignment_2() { return cSinglelogalexpAssignment_2; }
		
		//SingleLogalExp
		public RuleCall getSinglelogalexpSingleLogalExpParserRuleCall_2_0() { return cSinglelogalexpSingleLogalExpParserRuleCall_2_0; }
	}
	public class EIntElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.EInt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//EInt ecore::EInt:
		//	'-'? INT;
		@Override public ParserRule getRule() { return rule; }
		
		//'-'? INT
		public Group getGroup() { return cGroup; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}
	public class MessagesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Messages");
		private final RuleCall cSTRINGTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Messages:
		//	STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//STRING
		public RuleCall getSTRINGTerminalRuleCall() { return cSTRINGTerminalRuleCall; }
	}
	
	public class DirectionsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.Directions");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSouthEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSouthSouthKeyword_0_0 = (Keyword)cSouthEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNorthEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNorthNorthKeyword_1_0 = (Keyword)cNorthEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cWestEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cWestWestKeyword_2_0 = (Keyword)cWestEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cEastEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cEastEastKeyword_3_0 = (Keyword)cEastEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum Directions:
		//	south | north | west | east;
		public EnumRule getRule() { return rule; }
		
		//south | north | west | east
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//south
		public EnumLiteralDeclaration getSouthEnumLiteralDeclaration_0() { return cSouthEnumLiteralDeclaration_0; }
		
		//'south'
		public Keyword getSouthSouthKeyword_0_0() { return cSouthSouthKeyword_0_0; }
		
		//north
		public EnumLiteralDeclaration getNorthEnumLiteralDeclaration_1() { return cNorthEnumLiteralDeclaration_1; }
		
		//'north'
		public Keyword getNorthNorthKeyword_1_0() { return cNorthNorthKeyword_1_0; }
		
		//west
		public EnumLiteralDeclaration getWestEnumLiteralDeclaration_2() { return cWestEnumLiteralDeclaration_2; }
		
		//'west'
		public Keyword getWestWestKeyword_2_0() { return cWestWestKeyword_2_0; }
		
		//east
		public EnumLiteralDeclaration getEastEnumLiteralDeclaration_3() { return cEastEnumLiteralDeclaration_3; }
		
		//'east'
		public Keyword getEastEastKeyword_3_0() { return cEastEastKeyword_3_0; }
	}
	
	private final ScriptElements pScript;
	private final StatementsElements pStatements;
	private final LogicalExpsElements pLogicalExps;
	private final RunningStatementsElements pRunningStatements;
	private final CommandStatementElements pCommandStatement;
	private final BinariesElements pBinaries;
	private final SingleLogalExpElements pSingleLogalExp;
	private final EStringElements pEString;
	private final Statements_ImplElements pStatements_Impl;
	private final CommandStatement_ImplElements pCommandStatement_Impl;
	private final IfStatementElements pIfStatement;
	private final WhileStatementElements pWhileStatement;
	private final RepeatStatementElements pRepeatStatement;
	private final StepElements pStep;
	private final TurnLeftElements pTurnLeft;
	private final DropElements pDrop;
	private final PickElements pPick;
	private final TraceMessageElements pTraceMessage;
	private final CommentElements pComment;
	private final BuildStatements_ImplElements pBuildStatements_Impl;
	private final DestroyWallElements pDestroyWall;
	private final PickMarkElements pPickMark;
	private final DropMarkElements pDropMark;
	private final BuildWallElements pBuildWall;
	private final RunningStatements_ImplElements pRunningStatements_Impl;
	private final LogicalExps_ImplElements pLogicalExps_Impl;
	private final ElseElements pElse;
	private final FullElements pFull;
	private final MarkElements pMark;
	private final WallAheadElements pWallAhead;
	private final HeadingElements pHeading;
	private final SingleLogalExp_ImplElements pSingleLogalExp_Impl;
	private final BinaryLogicalExpElements pBinaryLogicalExp;
	private final NotElements pNot;
	private final DirectionsElements eDirections;
	private final Binaries_ImplElements pBinaries_Impl;
	private final AndElements pAnd;
	private final OrElements pOr;
	private final EIntElements pEInt;
	private final MessagesElements pMessages;
	private final TerminalRule tCOMMENTS;
	private final TerminalRule tNAME;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public RobotDSLGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pScript = new ScriptElements();
		this.pStatements = new StatementsElements();
		this.pLogicalExps = new LogicalExpsElements();
		this.pRunningStatements = new RunningStatementsElements();
		this.pCommandStatement = new CommandStatementElements();
		this.pBinaries = new BinariesElements();
		this.pSingleLogalExp = new SingleLogalExpElements();
		this.pEString = new EStringElements();
		this.pStatements_Impl = new Statements_ImplElements();
		this.pCommandStatement_Impl = new CommandStatement_ImplElements();
		this.pIfStatement = new IfStatementElements();
		this.pWhileStatement = new WhileStatementElements();
		this.pRepeatStatement = new RepeatStatementElements();
		this.pStep = new StepElements();
		this.pTurnLeft = new TurnLeftElements();
		this.pDrop = new DropElements();
		this.pPick = new PickElements();
		this.pTraceMessage = new TraceMessageElements();
		this.pComment = new CommentElements();
		this.pBuildStatements_Impl = new BuildStatements_ImplElements();
		this.pDestroyWall = new DestroyWallElements();
		this.pPickMark = new PickMarkElements();
		this.pDropMark = new DropMarkElements();
		this.pBuildWall = new BuildWallElements();
		this.pRunningStatements_Impl = new RunningStatements_ImplElements();
		this.pLogicalExps_Impl = new LogicalExps_ImplElements();
		this.pElse = new ElseElements();
		this.pFull = new FullElements();
		this.pMark = new MarkElements();
		this.pWallAhead = new WallAheadElements();
		this.pHeading = new HeadingElements();
		this.pSingleLogalExp_Impl = new SingleLogalExp_ImplElements();
		this.pBinaryLogicalExp = new BinaryLogicalExpElements();
		this.pNot = new NotElements();
		this.eDirections = new DirectionsElements();
		this.pBinaries_Impl = new Binaries_ImplElements();
		this.pAnd = new AndElements();
		this.pOr = new OrElements();
		this.pEInt = new EIntElements();
		this.pMessages = new MessagesElements();
		this.tCOMMENTS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.COMMENTS");
		this.tNAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "glt.RobotDSL.NAME");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("glt.RobotDSL".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Script:
	//	{Script}
	//	'Script'
	//	name=NAME
	//	'runs'
	//	'as' (statements+=Statements statements+=Statements*)?
	//	'end';
	public ScriptElements getScriptAccess() {
		return pScript;
	}
	
	public ParserRule getScriptRule() {
		return getScriptAccess().getRule();
	}
	
	//Statements:
	//	IfStatement | WhileStatement | RepeatStatement | Step | TurnLeft | Drop | Pick | TraceMessage | Comment | DestroyWall
	//	| PickMark | DropMark | BuildWall;
	public StatementsElements getStatementsAccess() {
		return pStatements;
	}
	
	public ParserRule getStatementsRule() {
		return getStatementsAccess().getRule();
	}
	
	//LogicalExps:
	//	Full | Mark | WallAhead | Heading | BinaryLogicalExp;
	public LogicalExpsElements getLogicalExpsAccess() {
		return pLogicalExps;
	}
	
	public ParserRule getLogicalExpsRule() {
		return getLogicalExpsAccess().getRule();
	}
	
	//RunningStatements:
	//	IfStatement | WhileStatement | RepeatStatement | Step | TurnLeft | Drop | Pick | TraceMessage | Comment;
	public RunningStatementsElements getRunningStatementsAccess() {
		return pRunningStatements;
	}
	
	public ParserRule getRunningStatementsRule() {
		return getRunningStatementsAccess().getRule();
	}
	
	//CommandStatement:
	//	Step | TurnLeft | Drop | Pick | TraceMessage | Comment;
	public CommandStatementElements getCommandStatementAccess() {
		return pCommandStatement;
	}
	
	public ParserRule getCommandStatementRule() {
		return getCommandStatementAccess().getRule();
	}
	
	//Binaries:
	//	And | Or;
	public BinariesElements getBinariesAccess() {
		return pBinaries;
	}
	
	public ParserRule getBinariesRule() {
		return getBinariesAccess().getRule();
	}
	
	//SingleLogalExp:
	//	Full | Mark | WallAhead | Heading;
	public SingleLogalExpElements getSingleLogalExpAccess() {
		return pSingleLogalExp;
	}
	
	public ParserRule getSingleLogalExpRule() {
		return getSingleLogalExpAccess().getRule();
	}
	
	//EString:
	//	STRING | ID;
	public EStringElements getEStringAccess() {
		return pEString;
	}
	
	public ParserRule getEStringRule() {
		return getEStringAccess().getRule();
	}
	
	//Statements_Impl Statements:
	//	{Statements}
	//	'Statements';
	public Statements_ImplElements getStatements_ImplAccess() {
		return pStatements_Impl;
	}
	
	public ParserRule getStatements_ImplRule() {
		return getStatements_ImplAccess().getRule();
	}
	
	//CommandStatement_Impl CommandStatement:
	//	{CommandStatement}
	//	'CommandStatement';
	public CommandStatement_ImplElements getCommandStatement_ImplAccess() {
		return pCommandStatement_Impl;
	}
	
	public ParserRule getCommandStatement_ImplRule() {
		return getCommandStatement_ImplAccess().getRule();
	}
	
	//IfStatement:
	//	{IfStatement}
	//	'if'
	//	logicalexps=LogicalExps
	//	'do' (runningstatements+=RunningStatements runningstatements+=RunningStatements*)?
	//	'end'
	//	else=Else?;
	public IfStatementElements getIfStatementAccess() {
		return pIfStatement;
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}
	
	//WhileStatement:
	//	{WhileStatement}
	//	'while'
	//	logicalexps=LogicalExps
	//	'do' (runningstatements+=RunningStatements runningstatements+=RunningStatements*)?
	//	'end';
	public WhileStatementElements getWhileStatementAccess() {
		return pWhileStatement;
	}
	
	public ParserRule getWhileStatementRule() {
		return getWhileStatementAccess().getRule();
	}
	
	//RepeatStatement:
	//	{RepeatStatement}
	//	'repeat'
	//	time=EInt
	//	'times' (commandstatement+=CommandStatement commandstatement+=CommandStatement*)?
	//	'end';
	public RepeatStatementElements getRepeatStatementAccess() {
		return pRepeatStatement;
	}
	
	public ParserRule getRepeatStatementRule() {
		return getRepeatStatementAccess().getRule();
	}
	
	//Step:
	//	{Step}
	//	'step';
	public StepElements getStepAccess() {
		return pStep;
	}
	
	public ParserRule getStepRule() {
		return getStepAccess().getRule();
	}
	
	//TurnLeft:
	//	{TurnLeft}
	//	'turnLeft';
	public TurnLeftElements getTurnLeftAccess() {
		return pTurnLeft;
	}
	
	public ParserRule getTurnLeftRule() {
		return getTurnLeftAccess().getRule();
	}
	
	//Drop:
	//	{Drop}
	//	'drop';
	public DropElements getDropAccess() {
		return pDrop;
	}
	
	public ParserRule getDropRule() {
		return getDropAccess().getRule();
	}
	
	//Pick:
	//	{Pick}
	//	'pick';
	public PickElements getPickAccess() {
		return pPick;
	}
	
	public ParserRule getPickRule() {
		return getPickAccess().getRule();
	}
	
	//TraceMessage:
	//	{TraceMessage}
	//	'trace'
	//	message=Messages;
	public TraceMessageElements getTraceMessageAccess() {
		return pTraceMessage;
	}
	
	public ParserRule getTraceMessageRule() {
		return getTraceMessageAccess().getRule();
	}
	
	//Comment:
	//	{Comment} comment=COMMENTS;
	public CommentElements getCommentAccess() {
		return pComment;
	}
	
	public ParserRule getCommentRule() {
		return getCommentAccess().getRule();
	}
	
	//BuildStatements_Impl BuildStatements:
	//	{BuildStatements}
	//	'BuildStatements';
	public BuildStatements_ImplElements getBuildStatements_ImplAccess() {
		return pBuildStatements_Impl;
	}
	
	public ParserRule getBuildStatements_ImplRule() {
		return getBuildStatements_ImplAccess().getRule();
	}
	
	//DestroyWall:
	//	{DestroyWall}
	//	'destroyWall'
	//	'at'
	//	'row:'
	//	row=INT
	//	'col:'
	//	column=INT;
	public DestroyWallElements getDestroyWallAccess() {
		return pDestroyWall;
	}
	
	public ParserRule getDestroyWallRule() {
		return getDestroyWallAccess().getRule();
	}
	
	//PickMark:
	//	{PickMark}
	//	'pickMark'
	//	'at'
	//	'row:'
	//	row=INT
	//	'col:'
	//	column=INT;
	public PickMarkElements getPickMarkAccess() {
		return pPickMark;
	}
	
	public ParserRule getPickMarkRule() {
		return getPickMarkAccess().getRule();
	}
	
	//DropMark:
	//	{DropMark}
	//	'dropMark'
	//	'at'
	//	'row:'
	//	row=INT
	//	'col:'
	//	column=INT;
	public DropMarkElements getDropMarkAccess() {
		return pDropMark;
	}
	
	public ParserRule getDropMarkRule() {
		return getDropMarkAccess().getRule();
	}
	
	//BuildWall:
	//	{BuildWall}
	//	'buildWall'
	//	'at'
	//	'row:'
	//	row=INT
	//	'col:'
	//	column=INT;
	public BuildWallElements getBuildWallAccess() {
		return pBuildWall;
	}
	
	public ParserRule getBuildWallRule() {
		return getBuildWallAccess().getRule();
	}
	
	//RunningStatements_Impl RunningStatements:
	//	{RunningStatements}
	//	'RunningStatements';
	public RunningStatements_ImplElements getRunningStatements_ImplAccess() {
		return pRunningStatements_Impl;
	}
	
	public ParserRule getRunningStatements_ImplRule() {
		return getRunningStatements_ImplAccess().getRule();
	}
	
	//LogicalExps_Impl LogicalExps:
	//	{LogicalExps}
	//	'LogicalExps';
	public LogicalExps_ImplElements getLogicalExps_ImplAccess() {
		return pLogicalExps_Impl;
	}
	
	public ParserRule getLogicalExps_ImplRule() {
		return getLogicalExps_ImplAccess().getRule();
	}
	
	//Else:
	//	{Else}
	//	'else'
	//	'do' (runningstatements+=RunningStatements runningstatements+=RunningStatements*)?
	//	'end';
	public ElseElements getElseAccess() {
		return pElse;
	}
	
	public ParserRule getElseRule() {
		return getElseAccess().getRule();
	}
	
	//Full:
	//	{Full} not=Not?
	//	'full';
	public FullElements getFullAccess() {
		return pFull;
	}
	
	public ParserRule getFullRule() {
		return getFullAccess().getRule();
	}
	
	//Mark:
	//	{Mark} not=Not?
	//	'mark';
	public MarkElements getMarkAccess() {
		return pMark;
	}
	
	public ParserRule getMarkRule() {
		return getMarkAccess().getRule();
	}
	
	//WallAhead:
	//	{WallAhead} not=Not?
	//	'wall'
	//	'ahead';
	public WallAheadElements getWallAheadAccess() {
		return pWallAhead;
	}
	
	public ParserRule getWallAheadRule() {
		return getWallAheadAccess().getRule();
	}
	
	//Heading:
	//	{Heading} not=Not?
	//	'heading'
	//	direction=Directions;
	public HeadingElements getHeadingAccess() {
		return pHeading;
	}
	
	public ParserRule getHeadingRule() {
		return getHeadingAccess().getRule();
	}
	
	//SingleLogalExp_Impl SingleLogalExp:
	//	{SingleLogalExp}
	//	'SingleLogalExp';
	public SingleLogalExp_ImplElements getSingleLogalExp_ImplAccess() {
		return pSingleLogalExp_Impl;
	}
	
	public ParserRule getSingleLogalExp_ImplRule() {
		return getSingleLogalExp_ImplAccess().getRule();
	}
	
	//BinaryLogicalExp:
	//	singlelogalexp=SingleLogalExp
	//	binaries+=Binaries+;
	public BinaryLogicalExpElements getBinaryLogicalExpAccess() {
		return pBinaryLogicalExp;
	}
	
	public ParserRule getBinaryLogicalExpRule() {
		return getBinaryLogicalExpAccess().getRule();
	}
	
	//Not:
	//	{Not}
	//	'not';
	public NotElements getNotAccess() {
		return pNot;
	}
	
	public ParserRule getNotRule() {
		return getNotAccess().getRule();
	}
	
	//enum Directions:
	//	south | north | west | east;
	public DirectionsElements getDirectionsAccess() {
		return eDirections;
	}
	
	public EnumRule getDirectionsRule() {
		return getDirectionsAccess().getRule();
	}
	
	//Binaries_Impl Binaries:
	//	{Binaries}
	//	'Binaries';
	public Binaries_ImplElements getBinaries_ImplAccess() {
		return pBinaries_Impl;
	}
	
	public ParserRule getBinaries_ImplRule() {
		return getBinaries_ImplAccess().getRule();
	}
	
	//And:
	//	{And}
	//	'and'
	//	singlelogalexp=SingleLogalExp;
	public AndElements getAndAccess() {
		return pAnd;
	}
	
	public ParserRule getAndRule() {
		return getAndAccess().getRule();
	}
	
	//Or:
	//	{Or}
	//	'or'
	//	singlelogalexp=SingleLogalExp;
	public OrElements getOrAccess() {
		return pOr;
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}
	
	//EInt ecore::EInt:
	//	'-'? INT;
	public EIntElements getEIntAccess() {
		return pEInt;
	}
	
	public ParserRule getEIntRule() {
		return getEIntAccess().getRule();
	}
	
	//Messages:
	//	STRING;
	public MessagesElements getMessagesAccess() {
		return pMessages;
	}
	
	public ParserRule getMessagesRule() {
		return getMessagesAccess().getRule();
	}
	
	//terminal COMMENTS:
	//	'#' ('a'..'z' | 'A'..'Z' | '_' | '0'..'9' | ' ' |
	//	'!' | '*' | '&' | '^' | '%' | '$' | '@' | '(' | ')' |
	//	'-' | '=' | '+' | '[' | ']' | '{' | '}' | ';' | ':' |
	//	',' | '<' | '.' | '/' | '>' | '?')* '\n';
	public TerminalRule getCOMMENTSRule() {
		return tCOMMENTS;
	}
	
	//terminal NAME:
	//	'a'..'z' | 'A'..'Z'+;
	public TerminalRule getNAMERule() {
		return tNAME;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
